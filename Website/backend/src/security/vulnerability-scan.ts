import { exec } from 'child_process';
import fs from 'fs';
import path from 'path';
import logger from '../utils/logger';
import { AuditLogger } from '../utils/auditLogger';

// Vulnerability scan results interface
interface VulnerabilityScanResult {
  id: string;
  timestamp: Date;
  scanType: string;
  findings: Array<{
    severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
    title: string;
    description: string;
    location?: string;
    recommendation?: string;
  }>;
  summary: {
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
    total: number;
  };
}

// In-memory store for scan results (use database in production)
const scanResults: VulnerabilityScanResult[] = [];

// Directory for scan reports
const scanReportsDir = path.join(__dirname, '../../scan-reports');

// Ensure scan reports directory exists
if (!fs.existsSync(scanReportsDir)) {
  fs.mkdirSync(scanReportsDir, { recursive: true });
}

// Run dependency vulnerability scan
export async function scanDependencies(): Promise<VulnerabilityScanResult> {
  return new Promise((resolve, reject) => {
    const scanId = `dep-scan-${Date.now()}`;
    const outputFile = path.join(scanReportsDir, `${scanId}.json`);
    
    logger.info('Starting dependency vulnerability scan');
    
    // Use npm audit to scan dependencies
    exec('npm audit --json', (error, stdout) => {
      try {
        // Parse npm audit output
        const auditData = JSON.parse(stdout);
        
        // Transform to our result format
        const result: VulnerabilityScanResult = {
          id: scanId,
          timestamp: new Date(),
          scanType: 'dependency',
          findings: [],
          summary: {
            critical: 0,
            high: 0,
            medium: 0,
            low: 0,
            info: 0,
            total: 0
          }
        };
        
        // Process vulnerabilities
        if (auditData.vulnerabilities) {
          for (const [pkgName, vuln] of Object.entries(auditData.vulnerabilities)) {
            const vulnerability = vuln as any;
            const severity = vulnerability.severity as 'critical' | 'high' | 'medium' | 'low' | 'info';
            
            result.findings.push({
              severity,
              title: `${pkgName} - ${vulnerability.name || 'Unknown vulnerability'}`,
              description: vulnerability.overview || 'No description available',
              location: `node_modules/${pkgName}`,
              recommendation: vulnerability.recommendation || 'Update to the latest version'
            });
            
            // Update summary counts
            result.summary[severity]++;
            result.summary.total++;
          }
        }
        
        // Save scan result
        fs.writeFileSync(outputFile, JSON.stringify(result, null, 2));
        scanResults.push(result);
        
        // Log scan completion
        logger.info('Dependency vulnerability scan completed', {
          scanId,
          findings: result.summary.total
        });
        
        // Log to audit log if critical or high vulnerabilities found
        if (result.summary.critical > 0 || result.summary.high > 0) {
          AuditLogger.logSecurity('vulnerability_scan_alert', {
            scanId,
            critical: result.summary.critical,
            high: result.summary.high,
            total: result.summary.total
          });
        }
        
        resolve(result);
      } catch (err) {
        logger.error('Failed to parse dependency scan results', { error: (err as Error).message });
        reject(new Error('Failed to parse dependency scan results'));
      }
    });
  });
}

// Run code security scan
export async function scanCodeSecurity(): Promise<VulnerabilityScanResult> {
  return new Promise((resolve) => {
    const scanId = `code-scan-${Date.now()}`;
    const outputFile = path.join(scanReportsDir, `${scanId}.json`);
    
    logger.info('Starting code security scan');
    
    // In a real implementation, this would use a tool like SonarQube, ESLint security plugins, etc.
    // For this example, we'll simulate a scan with some findings
    
    const result: VulnerabilityScanResult = {
      id: scanId,
      timestamp: new Date(),
      scanType: 'code',
      findings: [
        {
          severity: 'medium',
          title: 'Potential SQL Injection',
          description: 'Raw user input used in database query',
          location: 'src/database/repositories/UserRepository.ts:45',
          recommendation: 'Use parameterized queries or an ORM'
        },
        {
          severity: 'low',
          title: 'Insecure Random Values',
          description: 'Math.random() used for security-sensitive operation',
          location: 'src/auth/security.ts:78',
          recommendation: 'Use crypto.randomBytes() instead'
        }
      ],
      summary: {
        critical: 0,
        high: 0,
        medium: 1,
        low: 1,
        info: 0,
        total: 2
      }
    };
    
    // Save scan result
    fs.writeFileSync(outputFile, JSON.stringify(result, null, 2));
    scanResults.push(result);
    
    // Log scan completion
    logger.info('Code security scan completed', {
      scanId,
      findings: result.summary.total
    });
    
    resolve(result);
  });
}

// Run configuration security scan
export async function scanConfigSecurity(): Promise<VulnerabilityScanResult> {
  return new Promise((resolve) => {
    const scanId = `config-scan-${Date.now()}`;
    const outputFile = path.join(scanReportsDir, `${scanId}.json`);
    
    logger.info('Starting configuration security scan');
    
    // In a real implementation, this would check for insecure configurations
    // For this example, we'll simulate a scan with some findings
    
    const result: VulnerabilityScanResult = {
      id: scanId,
      timestamp: new Date(),
      scanType: 'config',
      findings: [
        {
          severity: 'high',
          title: 'Default JWT Secret',
          description: 'JWT_SECRET environment variable using default value',
          location: '.env',
          recommendation: 'Set a strong, unique JWT_SECRET in production environment'
        },
        {
          severity: 'medium',
          title: 'Missing Rate Limiting',
          description: 'Some API endpoints are not protected by rate limiting',
          location: 'src/api/reports/index.ts',
          recommendation: 'Apply rate limiting middleware to all routes'
        }
      ],
      summary: {
        critical: 0,
        high: 1,
        medium: 1,
        low: 0,
        info: 0,
        total: 2
      }
    };
    
    // Save scan result
    fs.writeFileSync(outputFile, JSON.stringify(result, null, 2));
    scanResults.push(result);
    
    // Log scan completion
    logger.info('Configuration security scan completed', {
      scanId,
      findings: result.summary.total
    });
    
    // Log to audit log if critical or high vulnerabilities found
    if (result.summary.critical > 0 || result.summary.high > 0) {
      AuditLogger.logSecurity('vulnerability_scan_alert', {
        scanId,
        critical: result.summary.critical,
        high: result.summary.high,
        total: result.summary.total
      });
    }
    
    resolve(result);
  });
}

// Get scan results
export function getScanResults(scanId?: string): VulnerabilityScanResult | VulnerabilityScanResult[] | null {
  if (scanId) {
    return scanResults.find(result => result.id === scanId) || null;
  }
  
  return scanResults;
}

// Schedule regular vulnerability scans
export function scheduleVulnerabilityScans() {
  // Schedule dependency scan (daily)
  const dailyScanInterval = 24 * 60 * 60 * 1000; // 24 hours
  
  // Initial scans
  setTimeout(() => {
    scanDependencies().catch(err => {
      logger.error('Scheduled dependency scan failed', { error: (err as Error).message });
    });
  }, 10000); // Run first scan after 10 seconds
  
  // Schedule recurring scans
  setInterval(() => {
    scanDependencies().catch(err => {
      logger.error('Scheduled dependency scan failed', { error: (err as Error).message });
    });
  }, dailyScanInterval);
  
  // Schedule code security scan (weekly)
  const weeklyScanInterval = 7 * 24 * 60 * 60 * 1000; // 7 days
  
  setTimeout(() => {
    scanCodeSecurity().catch(err => {
      logger.error('Scheduled code security scan failed', { error: (err as Error).message });
    });
  }, 60000); // Run first scan after 1 minute
  
  setInterval(() => {
    scanCodeSecurity().catch(err => {
      logger.error('Scheduled code security scan failed', { error: (err as Error).message });
    });
  }, weeklyScanInterval);
  
  // Schedule configuration security scan (weekly)
  setTimeout(() => {
    scanConfigSecurity().catch(err => {
      logger.error('Scheduled configuration security scan failed', { error: (err as Error).message });
    });
  }, 120000); // Run first scan after 2 minutes
  
  setInterval(() => {
    scanConfigSecurity().catch(err => {
      logger.error('Scheduled configuration security scan failed', { error: (err as Error).message });
    });
  }, weeklyScanInterval);
  
  logger.info('Vulnerability scan schedules initialized');
}

// Individual scheduling functions for specific scan types
export function scheduleDependencyScan(intervalMs: number = 24 * 60 * 60 * 1000) {
  // Initial scan
  setTimeout(() => {
    scanDependencies().catch(err => {
      logger.error('Scheduled dependency scan failed', { error: (err as Error).message });
    });
  }, 10000); // Run first scan after 10 seconds
  
  // Schedule recurring scans
  setInterval(() => {
    scanDependencies().catch(err => {
      logger.error('Scheduled dependency scan failed', { error: (err as Error).message });
    });
  }, intervalMs);
  
  logger.info(`Dependency vulnerability scan scheduled with interval: ${intervalMs}ms`);
}

export function scheduleCodeScan(intervalMs: number = 7 * 24 * 60 * 60 * 1000) {
  // Initial scan
  setTimeout(() => {
    scanCodeSecurity().catch(err => {
      logger.error('Scheduled code security scan failed', { error: (err as Error).message });
    });
  }, 60000); // Run first scan after 1 minute
  
  // Schedule recurring scans
  setInterval(() => {
    scanCodeSecurity().catch(err => {
      logger.error('Scheduled code security scan failed', { error: (err as Error).message });
    });
  }, intervalMs);
  
  logger.info(`Code security scan scheduled with interval: ${intervalMs}ms`);
}

export function scheduleConfigScan(intervalMs: number = 7 * 24 * 60 * 60 * 1000) {
  // Initial scan
  setTimeout(() => {
    scanConfigSecurity().catch(err => {
      logger.error('Scheduled configuration security scan failed', { error: (err as Error).message });
    });
  }, 120000); // Run first scan after 2 minutes
  
  // Schedule recurring scans
  setInterval(() => {
    scanConfigSecurity().catch(err => {
      logger.error('Scheduled configuration security scan failed', { error: (err as Error).message });
    });
  }, intervalMs);
  
  logger.info(`Configuration security scan scheduled with interval: ${intervalMs}ms`);
}